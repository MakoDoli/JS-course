<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="style.css" />
    <title>JS basics</title>
  </head>
  <body>
    <button><a href="./numbers.html" target="_blank">NUMBERS</a></button>
    <button><a href="./strings.html" target="_blank">STRINGS</a></button>
    <button>
      <a href="./variables.html" target="_blank">VARIABLES<br />&SCOPES</a>
    </button>
    <button>
      <a href="./hoisting.html" target="_blank">HOISTING</a>
    </button>
    <p>
      Javascript takes all functions declared with "function" keyword and drags
      on top of the code.
    </p>
    <p>functions declared with const are NOT hoisted.</p>
    <p>
      funcitons declared with var are NOT hoisted, <br />
      but ordinary variables declared with var are initialized before being
      declared (we will get "udefined" instead of error)
    </p>
    <p>
      UNDEFINED means Variable has been declared but value is not ASSIGNED but
      NOT DEFINED means Variables is NOT DECLARED.
    </p>
    <ul style="width: 70%">
      <li>
        Before starting to run even the first line of code, JavaScript first
        creates global execution memory allocations for each variable (var, let,
        const,) in the entire code file (var is set to "undefined" at this
        point). Functions declared with the keyword "function" are fully
        created. That's why we can access functions anytime from anywhere, no
        matter where or when they are created in the global scope. Functions
        created with the variable keyword are treated as variables, so they are
        also undefined at creation phase.
      </li>
      <li>
        Then, JavaScript begins to read and execute the code line by line: it
        assigns values to already initialized variables or executes functions.
        When it encounters a function, Execution control goes to this function.
        JS puts this function in the call stack and starts to execute it. If
        there is another new nested function inside this function, JS puts this
        new nested function on top of the parent function in the call stack.
      </li>
      <li>
        Inside the global execution process,new "execution process" is created
        for current function. JS reads the function body line by line. If it
        encounters a variable inside the block, JS looks for this variable
        within the block scope in the code lines before this line. If it cannot
        find it there, it looks upwards in the parent block but only in the part
        that was read at the time of putting this new function in the call
        stack. If it still cannot find it in the parent function, it goes out to
        the global scope and looks for the variable there. If it is new
        variable, then it creates new memory allocation for this variable.
      </li>
      <li>
        After "return", execution goes back to that line where function was
        envoked, and temporary execution process of finished function is deleted
      </li>
    </ul>
    <script src="hoisting.js"></script>
  </body>
</html>
